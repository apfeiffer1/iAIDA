#!/usr/bin/env python2

import os, os.path, sys, string

# History:
# ap, 06-nov-2005  : update for slc4, and gcc 344/40; add detection of h/w arch
# ap, 16-mar-2005  : add optional platform switch to let the user override the
#                    automatic detection of the platform
# ap, 29-jun-2004  : add check for Scientific Linux 3.0.2, more detailled check
#                    on the g++ version to find 3.2.3 correctly, error printouts
#                    for unknown opSys and/or compiler, improved checks for AIDA
#                    dir, added PYTHONPATH and python shared libs to runtime env.
# ap, some time ago: script created



def guessHWArch() :

    hwArch = "ia32" # set some default to make it work ...

    arch = os.uname()[-1]

    import re
    if re.compile( 'i\d86').match(arch) : hwArch = "ia32"
    if re.compile('x86_64').match(arch) : hwArch = "amd64"
    if re.compile(  'ia64').match(arch) : hwArch = "ia64"

    return hwArch


def guessPlatform() :
    opSys = None
    comp  = None

    # simple guesser ...
    if ( os.uname()[0] == "SunOS" ) :
        opSys = "sun4x_58"  # for now ...
        chOutErr = os.popen("CC -V", 'r')
        compString = string.join(chOutErr.readlines())[:-1]  # skip \n
        chOutErr.close()
        #print "got: '" + compString + "'"
        comp = "CC-" + compString.split()[7]

    elif ( os.uname()[0] == "Linux" ) :
        try:
            # try this one first, as /etc/issue may contain announcements
            issue = open("/etc/redhat-release", 'r')
        except IOError:
            issue = open("/etc/issue", 'r')
        except:
            raise
        lines = string.join(issue.readlines())
        issue.close()
        if ( string.find(lines, "Red Hat") != -1 and
             string.find(lines, "7.3") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "Red Hat") != -1 and
             string.find(lines, "9") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "Red Hat") != -1 and
             string.find(lines, "9") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "Red Hat Enterprise") != -1 and
             string.find(lines, "release 3") != -1 ) : opSys = "slc3_ia32"
        elif ( string.find(lines, "CERN E. Linux") != -1 and
             string.find(lines, "test") != -1 ) : opSys = "cel3-i386"
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, "3.0.2") != -1 ) : opSys = "cel3-i386"
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, "3.0.3") != -1 ) : opSys = "slc3_ia32"
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, "3.0.4") != -1 ) : opSys = "slc3_ia32"
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, "3.0.5") != -1 ) : opSys = "slc3_ia32"
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, "3.0.") != -1 ) : opSys = "slc3_" + guessHWArch() # catch all for 3.0.x, assumes binary compatibility !
        elif ( string.find(lines, "Scientific Linux") != -1 and
             string.find(lines, " 4.") != -1 ) : opSys = "slc4_" + guessHWArch() # catch all for 4.x, assumes binary compatibility !
        elif ( string.find(lines, "Red Hat Enterprise Linux") != -1 and
             string.find(lines, "elease 3") != -1 ) : opSys = "slc3_" + guessHWArch()
        elif ( string.find(lines, "Red Hat Enterprise Linux") != -1 and
             string.find(lines, "elease 4") != -1 ) : opSys = "slc4_" + guessHWArch()
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "8.0") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "8.1") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "8.2") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "8.2") != -1 ) : opSys = "rh73"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "9.0") != -1 ) : opSys = "cel3-i386"  # guess !
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "9.1") != -1 ) : opSys = "suse91"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "9.2") != -1 ) : opSys = "suse92"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "9.3") != -1 ) : opSys = "suse93"
        elif ( string.find(lines, "SuSE") != -1 and
             string.find(lines, "10.0") != -1 ) : opSys = "suse100"

        if not opSys :
            # errLog = open(".guessPlatf-os.err",'w')
            # errLog.write("\nUnknown operating system found, please report:\n" + lines + "\n")
            # errLog.close()
            sys.stderr.write("\nERROR:\n")
            sys.stderr.write("\tOperating system version '" + lines + "' is not supported, sorry.\n")
            sys.stderr.write("\tFor information on supported platforms and porting see http://cern.ch/pi \n\n")
            sys.exit(-1)

        chOutErr = os.popen("g++ --version", 'r')
        compString = string.join(chOutErr.readlines())[:-1]  # skip \n
        chOutErr.close()
        #print "got: '" + compString + "'"
        # differentiate between these two !
        if ( string.find(compString, "g++ (GCC) 3.2") != -1 ) : comp = "gcc32"
        if ( string.find(compString, "g++ (GCC) 3.2.3") != -1 ) : comp = "gcc323"
        # On SuSE 8.2 the compiler is 3.3 ...
        if ( string.find(compString, "g++ (GCC) 3.3") != -1 ) : comp = "gcc33"
        # prepare for newer ones
        if ( string.find(compString, "g++ (GCC) 3.4.3") != -1 ) : comp = "gcc343"
        if ( string.find(compString, "g++ (GCC) 3.4.4") != -1 ) : comp = "gcc344"
        if ( string.find(compString, "g++ (GCC) 4.0") != -1 ) : comp = "gcc40"
        
        if not comp :
            # errLog = open(".guessPlatf-comp.err",'w')
            # errLog.write("\nUnknown compiler version found, please report:\n" + compString + "\n")
            # errLog.close()
            sys.stderr.write("\nERROR:\n")
            sys.stderr.write("\tCompiler version '" + compString + "' is not supported, sorry.\n")
            sys.stderr.write("\tFor information on supported platforms and porting see http://cern.ch/pi \n\n")
            sys.exit(-1)

    return (opSys, comp)

# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------

# --------------------------------------------------------------------------------

def usage ():
   print """

usage: aida-config [<options>] 

where the optional <options> can be one of the following:

       -?, -h, --help : print this text
       -v, --version  : print version info

       -i, --includes : print out the list for the include directories: '-I...'
       -c, --cflags   : presently as -i or --includes
       -l, --libs     : print out the list for the libraries : '-L... -l.. -l.. ...'
       -r, --runtime  : print out the list to be added to the SharedLib Path : '<path-to-shared-libs>'

       --platform=<platform> : use <platform> for Platform string, overrides automatic determination

"""



# --------------------------------------------------------------------------------

class AIDA_Configurator :

    def __init__(self, platf=None) :

        self.piVersion   = "PI_1_3_12"
        self.sealVersion = "SEAL_1_7_9"
        self.aidaVersion = "3.2.1"

        self.versionPython = "2.4.2"
        self.versionRoot   = "5.08.00"
        self.versionBoost  = "1.32.0"

        self.platf = plat

        self.setup()

        return

    def setup(self) :

        if not self.platf :
            (opSys, comp) = guessPlatform()
            self.platf = opSys + "_" + str(comp)

        myPath = os.path.realpath(sys.argv[0]) 
        pathToSelf, name = os.path.split( myPath )

        words = string.split(pathToSelf, "/")
        self.topDir = string.join( words[:-4], "/")

        # check if topDir exists and if it contains this script :-)
        if ( not os.path.exists(self.topDir) or
             not os.path.exists(self.topDir + "/PI/" + self.piVersion  + "/" + self.platf + "/bin/aida-config") ) :
            # ... not existing, check for environment var PI_DIR:
            try:
                self.topDir = os.environ["PI_DIR"]  # the path to /where/ever/app/releases where PI is in ...
            except KeyError:
                sys.stderr.write("\nERROR:\n")
                sys.stderr.write("\tEnvironment variable PI_DIR is not set and the estimated directory not accessible.\n")
                sys.stderr.write("\tPlease make sure you define PI_DIR to point to your installation of PI. For more information\n")
                sys.stderr.write("\tsee http://cern.ch/pi \n\n")
                sys.stderr.write("\t(checked dir:" + self.topDir + ")\n\n")
                sys.exit(-1)
            except:
                raise

        # Now we should check where AIDA is in this tree :
        self.extDir = None

        self.analyzeDirPath(self.topDir)

        if not self.extDir :
            raise str("FATAL: Could not determine dir for external s/w !")
                
        self.piRelDir   = os.path.realpath( self.topDir + "/PI/" + self.piVersion + "/" + self.platf )
        self.sealRelDir = os.path.realpath( self.topDir + "/SEAL/" + self.sealVersion + "/" + self.platf )

        self.aidaTopDir     =  self.extDir + "/AIDA"
        self.aidaVersStr    =  str(self.aidaVersion)
        self.aidaDefaultDir =  self.aidaTopDir + "/" + self.aidaVersion + "/" + self.platf + "/src/cpp"
        if ( not os.path.exists( self.aidaDefaultDir ) ) :
            # try with "share" for platform
            self.aidaDefaultDir =  self.aidaTopDir + "/" + self.aidaVersion + "/share/src/cpp"
        self.aidaDefaultDir = os.path.realpath( self.aidaDefaultDir )

        return

# --------------------------------------------------------------------------------

    def analyzeDirPath(self, path) :
        self.extDir = None
        for index in range (-2, -5, -1) :
            checkDir = string.join( string.split(path, "/")[:index], "/") + "/external"
            if ( os.path.exists(checkDir) and 
                 os.path.exists(checkDir + "/AIDA/" + self.aidaVersion) ) :
                self.extDir = checkDir
                self.topDir = string.join( string.split(path, "/")[:index], "/") + "/app/releases"
        return

# --------------------------------------------------------------------------------

    def showInclude(self) :
        
        aidaDir = ""
        try : 
            aidaDir = os.environ["AIDA_DIR"]
        except:
            # not in environment, use "default installation from CERN cell
            aidaDir = self.aidaDefaultDir
            # check if it exists ...
            if ( not os.path.exists(aidaDir) ) :
                sys.stderr.write("\nERROR:\n")
                sys.stderr.write("\tEnvironment variable AIDA_DIR is not set and the default AFS directory not accessible.\n")
                sys.stderr.write("\tPlease make sure you have the AIDA interfaces installed. For more information\n")
                sys.stderr.write("\tsee http://aida.freehep.org\n\n")
                sys.stderr.write("\t(checked dir:" + aidaDir + ")\n\n")
                return
            
        print " -I" + aidaDir

        return

    # --------------------------------------------------------------------------------

    def showLibs(self) :

        libList = [ "lcg_AIDA_AnalysisFactory"
                    , "lcg_PluginManager"
                    , "lcg_SealBase"
                    , "lcg_AIDA_Plugin"
                  ]

        print "-L" + self.piRelDir   + "/lib " ,
        print "-L" + self.sealRelDir + "/lib " ,
        for lib in libList :
            print " -l" + lib,

        print " "
                    
        return


    # --------------------------------------------------------------------------------

    def showRuntime(self, arg) :

        # todo: cleanup PATH before setting: remove "old" versions in path 

        cmd = "export "
        sep = "="

        if ( string.find(arg, "csh") != -1 ) :
            cmd = "setenv "
            sep = " "

        setLDpath = cmd 
        setLDpath += " LD_LIBRARY_PATH" + sep + '"' + self.piRelDir + "/lib:"
        setLDpath += self.sealRelDir + '/lib:'
        setLDpath += self.extDir + "/Python/" + self.versionPython + "/" + self.platf + "/lib:"
        setLDpath += self.extDir + "/root/" + self.versionRoot + "/" + self.platf + "/root/lib:"
        setLDpath += self.extDir + "/Boost/" + self.versionBoost + "/" + self.platf + "/lib:"
        # add only if it is already defined, otherwise [t]csh will choke :-(((
        if (os.environ.has_key("LD_LIBRARY_PATH") ) :
            setLDpath += '${LD_LIBRARY_PATH}'            
        setLDpath += '";'
        print setLDpath

        print cmd + " SEAL_PLUGINS"    + sep + '"' + self.piRelDir + '/lib/modules:' + self.sealRelDir + '/lib/modules";' 

        setPyPath = cmd + " PYTHONPATH"  + sep + '"' + self.sealRelDir + "/lib:"
        setPyPath += self.sealRelDir + "/python:"
        setPyPath += self.piRelDir + "/python:"
        # add only if it is already defined, otherwise [t]csh will choke :-(((
        if (os.environ.has_key("PYTHONPATH") ) :
            setPyPath += '${PYTHONPATH}'
        setPyPath += '";'
        print setPyPath
        
        print cmd + " ROOTSYS"    + sep + self.extDir + "/root/" + self.versionRoot + "/" + self.platf + "/root;"

        return

    # --------------------------------------------------------------------------------

    def showVersion(self) :

        print "AIDA version ", self.aidaVersStr

        return

# ================================================================================

if __name__ == "__main__" :

    # --------------------------------------------------------------------------------
    # check if we got any flags:
    # --------------------------------------------------------------------------------
    
    import getopt
    try:
        optlist, args = getopt.getopt(sys.argv[1:], "?hviclr:", 
                                 ['help', 'version', 'includes', 'cflags', 'libs', 'runtime=', 'platform='])

        plat = None
        run  = None
        inc  = False
        lib  = False
        ver  = False
        
        for o, a in optlist:
            if o in ("-?", "-h", "--help"):
                usage()
                sys.exit()
            elif o in ("--platform",) :
                plat = a
            elif o in ("-v", "--version",):
                ver = True
            elif o in ("-i", "--includes",):
                inc = True
            elif o in ("-c", "--cflags",):
                inc = True
            elif o in ("-l", "--libs",):
                lib = True
            elif o in ("-r", "--runtime",):
                run = a
            else:
                print "\nunknown option:",o,"\n"
                usage()

            conf = AIDA_Configurator(plat)
            if ver :
                conf.showVersion()
                sys.exit()
            if inc :
                conf.showInclude()
            if lib :
                conf.showLibs()
            if run :
                conf.showRuntime(run)
                
    except :
        raise 


    
